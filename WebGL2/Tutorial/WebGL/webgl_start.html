<!DOCTYPE html>
<html>
<head><title> ClipsSpace </title>
<meta charset="utf-8">

    <!-- To jest biblioteka do operacji macierzowych -->
    <script type="text/javascript" src="gl-matrix-min.js"></script>


<script type="text/x-vertex" id="passthrough-vertex">
attribute vec4 aVertexPosition;

void main(void) {
    gl_Position  = aVertexPosition;
}
</script>

<script type="text/x-fragment" id="fixed-color-fragment">
precision mediump float;
varying vec4 vVertexColor;

void main(void) {
    gl_FragColor = vec4(1,0,0,1);
}
</script>

<script type="text/javascript">

function getTextFromTag(id) {
    var tag = document.getElementById(id);
    if (!tag) {
        return null;
    }

    var str = "";
    var k = tag.firstChild;
    while (k) {
        if (k.nodeType == Node.TEXT_NODE) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }
    return str;
}



/*
 Tablica zawierająca współrzędne  wierzchołków,
 każde trzy kolejne liczby oznaczają trzy współrzędne wierzchołka,
 a każde trzy kolejne wierzchołki wyznaczają jeden trójkąt
 Jeśli chcemy dodać kolejny trójkąt musimy dodać tu kolejne
 trzy wierzchołki czyli dziewięć współrzędnych.
 */
var VertexCoordinates = [
    0.0, 0.0, 1.0,
    -1.0, -1.0, -1.0,
    1.0, -1.0, -1.0
];

/*
 Pomocnicza funkcja która sprawdza czy WebGL
 zgłosił błąd  i jęśli tak wyświetla go na konsoli
 wraz z podanym przez nas jako drugi parametr komunikatem.
 Pierwszy parametr to context WebGL.
 */
function checkError(gl, msg) {
    var info = gl.getError();
    if (info != gl.NO_ERROR) {
        console.log("Error " + info + " : " + msg);
    }
}

/*
 Tak samo jak powyższa, ale zamiast wypisywać
 komunikat na konsoli wyświetla go w okienku
 dialogowym
 */
function alertError(gl, msg) {
    var info = gl.getError();
    if (info != gl.NO_ERROR) {
        alert("Error " + info + ": " + msg);
    }
}

/*
 Tu następuje seria pomocniczych funkcji, które
 ułatwiają napisanie programu WebGL. W każdej z nich
 pierwszy parametr to WebGL context.
 */

/*
 Funkcja kompiluje kod zawarty w parametrze 'src' za pomocą
 shadera 'shader'. W przypadku błędów kompilacji
 wyświetla stosowny komunikat na konsoli.
 */

function compileShader(gl, shader, src) {
    var info;
    gl.shaderSource(shader, src);
    checkError(gl,"loading shader source ");

    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

/*
 Funkcja pobiera z programu shadera 'shaderProgram' adres
 atrybuty o nazwie 'attributeName'.
 Następnie zapisuje ten adres
 w tablicy attribute będącej polem obiektu shader.
 */
function attachAttribute(gl, shaderProgram, attributeName) {
    if (!shaderProgram)
        console.log("shader is undefined ");

    var attributeLocation =
            gl.getAttribLocation(shaderProgram, attributeName);
    if (attributeLocation == -1) {
        console.log("cannot get attribute" + attributeName + "location");
    }

    gl.enableVertexAttribArray(attributeLocation);
    shaderProgram.attribute[attributeName] = attributeLocation;
}


/*
 Główna funkcja tworząca program cieniujący. Przed jej
 wywołaniem, należy zapisać w polach 'vShaderSrc' i 'fShaderSrc'
 kontekstu gl kody źródłowe obu shaderów.
 */
function initShaders(gl, attribs) {
    var vshader = gl.createShader(gl.VERTEX_SHADER);
    checkError(gl, 'creating vertex shader');

    var fshader = gl.createShader(gl.FRAGMENT_SHADER);
    checkError(gl, 'creating fragment shader');

    compileShader(gl, vshader, gl.vShaderSrc);
    compileShader(gl, fshader, gl.fShaderSrc);

    var shaderProgram = gl.createProgram();
    checkError(gl, 'creating program');


    gl.attachShader(shaderProgram, vshader);
    checkError(gl, 'attaching vshader');

    gl.attachShader(shaderProgram, fshader);
    checkError(gl, 'attaching fshader');

    gl.linkProgram(shaderProgram);
    var info = gl.getProgramParameter(shaderProgram, gl.LINK_STATUS);
    if (!info) {
        console.log("Could not initialise shaders " + info);
    }
    checkError(gl, 'linking program');

    gl.useProgram(shaderProgram);
    shaderProgram.attribute = {};
    gl.shaderProgram = shaderProgram;
    attribs.forEach(function (name) {
        attachAttribute(gl, shaderProgram, name);
    });
}

/*
 Funkcja  pobiera i zwraca adres zmienne uniform o nazwie
 'name' w programie 'shader'. Jeśli taka zmienna nie istnieje
 funkcja wypisuje stosowny komunikat na konsoli.
 */
function getUniformLocation(gl, shader, name) {
    var uniformLocation = gl.getUniformLocation(shader, name);
    if (!uniformLocation) {
        console.log("could not find uniform " + name);
    }
    return uniformLocation;
}

/*
 Funkcja tworząca bufor wierzchołków i ładująca do niego dane
 z tablicy 'data'. Parametr 'itemSize'
 określa ilość współrzędnych, a 'numItems' ilość wierzchołków.
 */
function initBuffer(gl, itemSize, numItems, data) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);

    return buffer;
}


function draw(gl) {
    console.log('drawing');
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
    gl.vertexAttribPointer(gl.shaderProgram.attribute['aVertexPosition'],
            3, gl.FLOAT, false, 0, 0);



    gl.drawArrays(gl.TRIANGLES, 0, 3);
    checkError(gl, "drawArrays");
}

// Funkcja która zostanie wykonana po całkowitym załadowaniu strony

function onLoad() {
    console.log('on load');
    //Odszukanie elementu canvas o zadanej nazwie
    var canvas = document.getElementById("canvas");
    //Jeśli się nie udało wyświetlamy stosowny komunikat
    if (!canvas) {
        alert("cannot get  canvas")
    }

    //Pobranie kontekstu WebGL z elementu canvas
    //i ustawienie  obszaru wyświetlania.
    var gl;
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewport(0, 0, canvas.width, canvas.height);
    } catch (e) {

    }
    //Jeśli się nie uda wyświetlamy stosowny komunikat
    if (!gl) {
        alert("Failed to get rendering context for WebGL")
    }


    //Tworzenie i załadowanie programu shadera
    gl.vShaderSrc = getTextFromTag("passthrough-vertex");
    gl.fShaderSrc = getTextFromTag("fixed-color-fragment");
    console.log(gl.fShaderSrc);
    initShaders(gl, ['aVertexPosition']);

    var vertexBuffer = initBuffer(gl, 3, 1, VertexCoordinates);

    gl.vertexBuffer = vertexBuffer;
    gl.enableVertexAttribArray(gl.shaderProgram.attribute['aVertexPosition']);


    // Ustawia kolor tła w formacie RGBA
    gl.clearColor(0.75, 0.75, 0.75, 1.0);
    // Włącza test głębokości
    gl.enable(gl.DEPTH_TEST);
    if ((info = gl.getError()) != gl.NO_ERROR) {
        console.log("Error " + info);
    }

    draw(gl);
}



</script>
</head>

<body onload="onLoad()">
<div>
    <canvas id="canvas" width="600" height="600"></canvas>
</div>
</body>
</html>
