<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>uj_list: uj::list&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uj_list
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classuj_1_1list.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classuj_1_1list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uj::list&lt; T, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward List providing C++98 std::list interface.  
 <a href="classuj_1_1list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="uj__list_8hpp_source.html">uj_list.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list_1_1citer.html">citer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const interator class.  <a href="classuj_1_1list_1_1citer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list_1_1iter.html">iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class.  <a href="classuj_1_1list_1_1iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuj_1_1list_1_1lnode.html">lnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private nested class of <a class="el" href="classuj_1_1list.html" title="Forward List providing C++98 std::list interface. ">uj::list</a>.  <a href="structuj_1_1list_1_1lnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuj_1_1list_1_1typenode.html">typenode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private nested class of <a class="el" href="classuj_1_1list.html" title="Forward List providing C++98 std::list interface. ">uj::list</a>.  <a href="structuj_1_1list_1_1typenode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f73131d3d2629368cd2163a4ad1e016"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a7f73131d3d2629368cd2163a4ad1e016">list</a> (const Allocator &amp;<a class="el" href="classuj_1_1list.html#a97b9c3bcf222cb2f16c5053f70332924">alloc</a>=Allocator())</td></tr>
<tr class="memdesc:a7f73131d3d2629368cd2163a4ad1e016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty list with given allocator.  <a href="#a7f73131d3d2629368cd2163a4ad1e016">More...</a><br /></td></tr>
<tr class="separator:a7f73131d3d2629368cd2163a4ad1e016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e99332f5254f5e14dcaf10ceca8d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a9f5e99332f5254f5e14dcaf10ceca8d9">list</a> (size_type count, const T &amp;value=T(), const Allocator &amp;<a class="el" href="classuj_1_1list.html#a97b9c3bcf222cb2f16c5053f70332924">alloc</a>=Allocator())</td></tr>
<tr class="memdesc:a9f5e99332f5254f5e14dcaf10ceca8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list with count copies of value and given allocator.  <a href="#a9f5e99332f5254f5e14dcaf10ceca8d9">More...</a><br /></td></tr>
<tr class="separator:a9f5e99332f5254f5e14dcaf10ceca8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0eb3ced8b9f1cecf8684eb0abb2a71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a8a0eb3ced8b9f1cecf8684eb0abb2a71">list</a> (const <a class="el" href="classuj_1_1list.html">list</a> &amp;other)</td></tr>
<tr class="memdesc:a8a0eb3ced8b9f1cecf8684eb0abb2a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list that is copy of other.  <a href="#a8a0eb3ced8b9f1cecf8684eb0abb2a71">More...</a><br /></td></tr>
<tr class="separator:a8a0eb3ced8b9f1cecf8684eb0abb2a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a154fc81ccbcc4c2959888eb07bd33"><td class="memTemplParams" colspan="2">template&lt;typename InIterator &gt; </td></tr>
<tr class="memitem:a26a154fc81ccbcc4c2959888eb07bd33"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a26a154fc81ccbcc4c2959888eb07bd33">list</a> (InIterator first, InIterator last, const Allocator &amp;<a class="el" href="classuj_1_1list.html#a97b9c3bcf222cb2f16c5053f70332924">alloc</a>=Allocator())</td></tr>
<tr class="memdesc:a26a154fc81ccbcc4c2959888eb07bd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs list of elements from range [first,last)  <a href="#a26a154fc81ccbcc4c2959888eb07bd33">More...</a><br /></td></tr>
<tr class="separator:a26a154fc81ccbcc4c2959888eb07bd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33555e4d12b70b7f4a549ee272c12e64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a33555e4d12b70b7f4a549ee272c12e64">~list</a> ()</td></tr>
<tr class="memdesc:a33555e4d12b70b7f4a549ee272c12e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a list.  <a href="#a33555e4d12b70b7f4a549ee272c12e64">More...</a><br /></td></tr>
<tr class="separator:a33555e4d12b70b7f4a549ee272c12e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2370564d27b189b6440e327d6c7d4119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a2370564d27b189b6440e327d6c7d4119">operator=</a> (const <a class="el" href="classuj_1_1list.html">list</a> &amp;other)</td></tr>
<tr class="memdesc:a2370564d27b189b6440e327d6c7d4119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces contents of *this with contents of other.  <a href="#a2370564d27b189b6440e327d6c7d4119">More...</a><br /></td></tr>
<tr class="separator:a2370564d27b189b6440e327d6c7d4119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3f16b79ad9f8ac02ed57561dd72f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ace3f16b79ad9f8ac02ed57561dd72f29">assign</a> (size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:ace3f16b79ad9f8ac02ed57561dd72f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces contents with count copies of value.  <a href="#ace3f16b79ad9f8ac02ed57561dd72f29">More...</a><br /></td></tr>
<tr class="separator:ace3f16b79ad9f8ac02ed57561dd72f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dabeac77f79554df076e5375638c972"><td class="memTemplParams" colspan="2">template&lt;typename InIterator &gt; </td></tr>
<tr class="memitem:a3dabeac77f79554df076e5375638c972"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a3dabeac77f79554df076e5375638c972">assign</a> (InIterator first, InIterator last)</td></tr>
<tr class="memdesc:a3dabeac77f79554df076e5375638c972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces contents with elements from range [first,last)  <a href="#a3dabeac77f79554df076e5375638c972">More...</a><br /></td></tr>
<tr class="separator:a3dabeac77f79554df076e5375638c972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259def13bbc1445e2356a366c4f9a648"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a259def13bbc1445e2356a366c4f9a648">get_allocator</a> () const </td></tr>
<tr class="memdesc:a259def13bbc1445e2356a366c4f9a648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of Allocator.  <a href="#a259def13bbc1445e2356a366c4f9a648">More...</a><br /></td></tr>
<tr class="separator:a259def13bbc1445e2356a366c4f9a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27be5e3365bf41da286c6459fc816cb"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae27be5e3365bf41da286c6459fc816cb">front</a> ()</td></tr>
<tr class="memdesc:ae27be5e3365bf41da286c6459fc816cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in list.  <a href="#ae27be5e3365bf41da286c6459fc816cb">More...</a><br /></td></tr>
<tr class="separator:ae27be5e3365bf41da286c6459fc816cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03b4c47003b188ccbb29cc439cf8940"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae03b4c47003b188ccbb29cc439cf8940">front</a> () const </td></tr>
<tr class="memdesc:ae03b4c47003b188ccbb29cc439cf8940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the first element in list.  <a href="#ae03b4c47003b188ccbb29cc439cf8940">More...</a><br /></td></tr>
<tr class="separator:ae03b4c47003b188ccbb29cc439cf8940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad351b071e23267df2b55a5695b10e89c"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ad351b071e23267df2b55a5695b10e89c">back</a> ()</td></tr>
<tr class="memdesc:ad351b071e23267df2b55a5695b10e89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in list.  <a href="#ad351b071e23267df2b55a5695b10e89c">More...</a><br /></td></tr>
<tr class="separator:ad351b071e23267df2b55a5695b10e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1860de7b9c9cc199f7fd59ca69d9c8cf"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a1860de7b9c9cc199f7fd59ca69d9c8cf">back</a> () const </td></tr>
<tr class="memdesc:a1860de7b9c9cc199f7fd59ca69d9c8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the last element in list.  <a href="#a1860de7b9c9cc199f7fd59ca69d9c8cf">More...</a><br /></td></tr>
<tr class="separator:a1860de7b9c9cc199f7fd59ca69d9c8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a1fe7d357ed44259df7a328b89c4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce">begin</a> () noexcept</td></tr>
<tr class="memdesc:af0a1fe7d357ed44259df7a328b89c4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element.  <a href="#af0a1fe7d357ed44259df7a328b89c4ce">More...</a><br /></td></tr>
<tr class="separator:af0a1fe7d357ed44259df7a328b89c4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f029f9af501bba9fc52311034cc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a708f029f9af501bba9fc52311034cc24">begin</a> () const  noexcept</td></tr>
<tr class="memdesc:a708f029f9af501bba9fc52311034cc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element.  <a href="#a708f029f9af501bba9fc52311034cc24">More...</a><br /></td></tr>
<tr class="separator:a708f029f9af501bba9fc52311034cc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3214ea407fe6a9db3fcbf6d76a0f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a2e3214ea407fe6a9db3fcbf6d76a0f5d">cbegin</a> () const  noexcept</td></tr>
<tr class="memdesc:a2e3214ea407fe6a9db3fcbf6d76a0f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the first element.  <a href="#a2e3214ea407fe6a9db3fcbf6d76a0f5d">More...</a><br /></td></tr>
<tr class="separator:a2e3214ea407fe6a9db3fcbf6d76a0f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72e3fd272936a3fd2078d16ed970507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507">end</a> () noexcept</td></tr>
<tr class="memdesc:aa72e3fd272936a3fd2078d16ed970507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator beyond the last element.  <a href="#aa72e3fd272936a3fd2078d16ed970507">More...</a><br /></td></tr>
<tr class="separator:aa72e3fd272936a3fd2078d16ed970507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cac95416397853029513a5cbf0a5b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a8cac95416397853029513a5cbf0a5b61">end</a> () const  noexcept</td></tr>
<tr class="memdesc:a8cac95416397853029513a5cbf0a5b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator beyond the last element.  <a href="#a8cac95416397853029513a5cbf0a5b61">More...</a><br /></td></tr>
<tr class="separator:a8cac95416397853029513a5cbf0a5b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf98eb7e3f25baefc1da8f1eb2e168d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a7cf98eb7e3f25baefc1da8f1eb2e168d">cend</a> () const  noexcept</td></tr>
<tr class="memdesc:a7cf98eb7e3f25baefc1da8f1eb2e168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator beyond the last element.  <a href="#a7cf98eb7e3f25baefc1da8f1eb2e168d">More...</a><br /></td></tr>
<tr class="separator:a7cf98eb7e3f25baefc1da8f1eb2e168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec29823b4a22c6dafb337ff87d733dd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#aec29823b4a22c6dafb337ff87d733dd7">empty</a> () const  noexcept</td></tr>
<tr class="memdesc:aec29823b4a22c6dafb337ff87d733dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the list has no elements.  <a href="#aec29823b4a22c6dafb337ff87d733dd7">More...</a><br /></td></tr>
<tr class="separator:aec29823b4a22c6dafb337ff87d733dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fe0df001bfc4f80f2a101980d18d1b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b">size</a> () const  noexcept</td></tr>
<tr class="memdesc:a33fe0df001bfc4f80f2a101980d18d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in list.  <a href="#a33fe0df001bfc4f80f2a101980d18d1b">More...</a><br /></td></tr>
<tr class="separator:a33fe0df001bfc4f80f2a101980d18d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac067128544c85d59c4ff6fdf09a13ca7"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ac067128544c85d59c4ff6fdf09a13ca7">max_size</a> () const  noexcept</td></tr>
<tr class="memdesc:ac067128544c85d59c4ff6fdf09a13ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the list can contain.  <a href="#ac067128544c85d59c4ff6fdf09a13ca7">More...</a><br /></td></tr>
<tr class="separator:ac067128544c85d59c4ff6fdf09a13ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c8cc0b559f340f0757bb792763f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a463c8cc0b559f340f0757bb792763f5a">clear</a> () noexcept</td></tr>
<tr class="memdesc:a463c8cc0b559f340f0757bb792763f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the list.  <a href="#a463c8cc0b559f340f0757bb792763f5a">More...</a><br /></td></tr>
<tr class="separator:a463c8cc0b559f340f0757bb792763f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff1eafb5e34e08f20d7576dc2c1a5f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a8ff1eafb5e34e08f20d7576dc2c1a5f1">insert</a> (<a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> pos, const T &amp;value)</td></tr>
<tr class="memdesc:a8ff1eafb5e34e08f20d7576dc2c1a5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element into the list.  <a href="#a8ff1eafb5e34e08f20d7576dc2c1a5f1">More...</a><br /></td></tr>
<tr class="separator:a8ff1eafb5e34e08f20d7576dc2c1a5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a80b374dbc39399f9b4e3a7d3bf0c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a7a80b374dbc39399f9b4e3a7d3bf0c9a">insert</a> (<a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> pos, size_type count, const T &amp;value)</td></tr>
<tr class="memdesc:a7a80b374dbc39399f9b4e3a7d3bf0c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count new elements into the list.  <a href="#a7a80b374dbc39399f9b4e3a7d3bf0c9a">More...</a><br /></td></tr>
<tr class="separator:a7a80b374dbc39399f9b4e3a7d3bf0c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8bae4452bdf6bfb3558dec5e77d4d3"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:add8bae4452bdf6bfb3558dec5e77d4d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#add8bae4452bdf6bfb3558dec5e77d4d3">insert</a> (<a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> pos, InputIt first, InputIt last)</td></tr>
<tr class="memdesc:add8bae4452bdf6bfb3558dec5e77d4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first,last) into the list.  <a href="#add8bae4452bdf6bfb3558dec5e77d4d3">More...</a><br /></td></tr>
<tr class="separator:add8bae4452bdf6bfb3558dec5e77d4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a06b19c1a88a347a0d66c8e776cde51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a3a06b19c1a88a347a0d66c8e776cde51">erase</a> (<a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> pos)</td></tr>
<tr class="memdesc:a3a06b19c1a88a347a0d66c8e776cde51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element pointed to by pos.  <a href="#a3a06b19c1a88a347a0d66c8e776cde51">More...</a><br /></td></tr>
<tr class="separator:a3a06b19c1a88a347a0d66c8e776cde51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa031574b1beddeec3a466964abb6b0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#aa031574b1beddeec3a466964abb6b0c3">erase</a> (<a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> first, <a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> last)</td></tr>
<tr class="memdesc:aa031574b1beddeec3a466964abb6b0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements in range [first,last)  <a href="#aa031574b1beddeec3a466964abb6b0c3">More...</a><br /></td></tr>
<tr class="separator:aa031574b1beddeec3a466964abb6b0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed0b58ea8be3d6cad70a1aa05503f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a6ed0b58ea8be3d6cad70a1aa05503f8b">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6ed0b58ea8be3d6cad70a1aa05503f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the end of the list.  <a href="#a6ed0b58ea8be3d6cad70a1aa05503f8b">More...</a><br /></td></tr>
<tr class="separator:a6ed0b58ea8be3d6cad70a1aa05503f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d2c229c12fa753deb71217266dc8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae8d2c229c12fa753deb71217266dc8b4">pop_back</a> ()</td></tr>
<tr class="memdesc:ae8d2c229c12fa753deb71217266dc8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from the list.  <a href="#ae8d2c229c12fa753deb71217266dc8b4">More...</a><br /></td></tr>
<tr class="separator:ae8d2c229c12fa753deb71217266dc8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4877f713b86765ffcf8e346e5780d3cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a4877f713b86765ffcf8e346e5780d3cf">push_front</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4877f713b86765ffcf8e346e5780d3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new element at the beginning of the list.  <a href="#a4877f713b86765ffcf8e346e5780d3cf">More...</a><br /></td></tr>
<tr class="separator:a4877f713b86765ffcf8e346e5780d3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0456766499b55969eb5cbcfb27884f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#afb0456766499b55969eb5cbcfb27884f">pop_front</a> ()</td></tr>
<tr class="memdesc:afb0456766499b55969eb5cbcfb27884f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from the list.  <a href="#afb0456766499b55969eb5cbcfb27884f">More...</a><br /></td></tr>
<tr class="separator:afb0456766499b55969eb5cbcfb27884f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae091e85fca96d1593bff39b1f8dcd95f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae091e85fca96d1593bff39b1f8dcd95f">resize</a> (size_type count, value_type value=T())</td></tr>
<tr class="memdesc:ae091e85fca96d1593bff39b1f8dcd95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes size of the list to count.  <a href="#ae091e85fca96d1593bff39b1f8dcd95f">More...</a><br /></td></tr>
<tr class="separator:ae091e85fca96d1593bff39b1f8dcd95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee7202eab1d35b5b6774e749d9497a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a3ee7202eab1d35b5b6774e749d9497a5">swap</a> (<a class="el" href="classuj_1_1list.html">list</a> &amp;other)</td></tr>
<tr class="memdesc:a3ee7202eab1d35b5b6774e749d9497a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of *this and other.  <a href="#a3ee7202eab1d35b5b6774e749d9497a5">More...</a><br /></td></tr>
<tr class="separator:a3ee7202eab1d35b5b6774e749d9497a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88cd7732f47f46ba7c7302d6c1c573f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae88cd7732f47f46ba7c7302d6c1c573f">merge</a> (<a class="el" href="classuj_1_1list.html">list</a> &amp;other)</td></tr>
<tr class="memdesc:ae88cd7732f47f46ba7c7302d6c1c573f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges sorted elements of two lists.  <a href="#ae88cd7732f47f46ba7c7302d6c1c573f">More...</a><br /></td></tr>
<tr class="separator:ae88cd7732f47f46ba7c7302d6c1c573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cb20c69d69bafab65cf73b0c21a168"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:aa3cb20c69d69bafab65cf73b0c21a168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#aa3cb20c69d69bafab65cf73b0c21a168">merge</a> (<a class="el" href="classuj_1_1list.html">list</a> &amp;other, Compare comp)</td></tr>
<tr class="memdesc:aa3cb20c69d69bafab65cf73b0c21a168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges sorted elements of two lists.  <a href="#aa3cb20c69d69bafab65cf73b0c21a168">More...</a><br /></td></tr>
<tr class="separator:aa3cb20c69d69bafab65cf73b0c21a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15767aa53fb9fb98286e1ec1143911a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a15767aa53fb9fb98286e1ec1143911a9">splice</a> (<a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> pos, <a class="el" href="classuj_1_1list.html">list</a> &amp;other)</td></tr>
<tr class="memdesc:a15767aa53fb9fb98286e1ec1143911a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all elements from other to *this.  <a href="#a15767aa53fb9fb98286e1ec1143911a9">More...</a><br /></td></tr>
<tr class="separator:a15767aa53fb9fb98286e1ec1143911a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936c2e0353fb70178f6e85e48e770907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a936c2e0353fb70178f6e85e48e770907">splice</a> (<a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> pos, <a class="el" href="classuj_1_1list.html">list</a> &amp;other, <a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> it)</td></tr>
<tr class="memdesc:a936c2e0353fb70178f6e85e48e770907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an element from other to *this.  <a href="#a936c2e0353fb70178f6e85e48e770907">More...</a><br /></td></tr>
<tr class="separator:a936c2e0353fb70178f6e85e48e770907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3927702816580e6670c7454e1ca1951f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a3927702816580e6670c7454e1ca1951f">splice</a> (<a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> pos, <a class="el" href="classuj_1_1list.html">list</a> &amp;other, <a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> first, <a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> last)</td></tr>
<tr class="memdesc:a3927702816580e6670c7454e1ca1951f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the elements from other to *this.  <a href="#a3927702816580e6670c7454e1ca1951f">More...</a><br /></td></tr>
<tr class="separator:a3927702816580e6670c7454e1ca1951f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c10b0a677be5a0330751da0520d529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a48c10b0a677be5a0330751da0520d529">remove</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a48c10b0a677be5a0330751da0520d529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements equal to value from the list.  <a href="#a48c10b0a677be5a0330751da0520d529">More...</a><br /></td></tr>
<tr class="separator:a48c10b0a677be5a0330751da0520d529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a028fabf75fd826088a7c5380e0ab94"><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a4a028fabf75fd826088a7c5380e0ab94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a4a028fabf75fd826088a7c5380e0ab94">remove_if</a> (UnaryPredicate p)</td></tr>
<tr class="memdesc:a4a028fabf75fd826088a7c5380e0ab94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements according to the predicate p.  <a href="#a4a028fabf75fd826088a7c5380e0ab94">More...</a><br /></td></tr>
<tr class="separator:a4a028fabf75fd826088a7c5380e0ab94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e47b0a6d938409f9522a83f4d165058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a9e47b0a6d938409f9522a83f4d165058">reverse</a> ()</td></tr>
<tr class="memdesc:a9e47b0a6d938409f9522a83f4d165058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of elements in the list.  <a href="#a9e47b0a6d938409f9522a83f4d165058">More...</a><br /></td></tr>
<tr class="separator:a9e47b0a6d938409f9522a83f4d165058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcb44aaa1d92c79e078bef09b676e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#addcb44aaa1d92c79e078bef09b676e16">unique</a> ()</td></tr>
<tr class="memdesc:addcb44aaa1d92c79e078bef09b676e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes consecutive duplicate elements from the list.  <a href="#addcb44aaa1d92c79e078bef09b676e16">More...</a><br /></td></tr>
<tr class="separator:addcb44aaa1d92c79e078bef09b676e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58091984701c4bb5083b958b6d554a1"><td class="memTemplParams" colspan="2">template&lt;class BinaryPredicate &gt; </td></tr>
<tr class="memitem:ae58091984701c4bb5083b958b6d554a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ae58091984701c4bb5083b958b6d554a1">unique</a> (BinaryPredicate p)</td></tr>
<tr class="memdesc:ae58091984701c4bb5083b958b6d554a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes consecutive duplicate elements from the list.  <a href="#ae58091984701c4bb5083b958b6d554a1">More...</a><br /></td></tr>
<tr class="separator:ae58091984701c4bb5083b958b6d554a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa3b9703aca075112c7a5adcc96e109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a7fa3b9703aca075112c7a5adcc96e109">sort</a> ()</td></tr>
<tr class="memdesc:a7fa3b9703aca075112c7a5adcc96e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts contents of the list.  <a href="#a7fa3b9703aca075112c7a5adcc96e109">More...</a><br /></td></tr>
<tr class="separator:a7fa3b9703aca075112c7a5adcc96e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41c18abc23c56a499420646852e4b4f"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:ab41c18abc23c56a499420646852e4b4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ab41c18abc23c56a499420646852e4b4f">sort</a> (Compare comp)</td></tr>
<tr class="memdesc:ab41c18abc23c56a499420646852e4b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts contents of the list.  <a href="#ab41c18abc23c56a499420646852e4b4f">More...</a><br /></td></tr>
<tr class="separator:ab41c18abc23c56a499420646852e4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeac48a411d84cacb4777a87fd093f437"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeac48a411d84cacb4777a87fd093f437"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuj_1_1list_1_1typenode.html">typenode</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#aeac48a411d84cacb4777a87fd093f437">getNode</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aeac48a411d84cacb4777a87fd093f437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and constructs typenode and element.  <a href="#aeac48a411d84cacb4777a87fd093f437">More...</a><br /></td></tr>
<tr class="separator:aeac48a411d84cacb4777a87fd093f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aec3cd86e562e8984b53cb9bba7684c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a1aec3cd86e562e8984b53cb9bba7684c">freeNode</a> (<a class="el" href="structuj_1_1list_1_1typenode.html">typenode</a> *node) noexcept</td></tr>
<tr class="memdesc:a1aec3cd86e562e8984b53cb9bba7684c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and deallocate given node.  <a href="#a1aec3cd86e562e8984b53cb9bba7684c">More...</a><br /></td></tr>
<tr class="separator:a1aec3cd86e562e8984b53cb9bba7684c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac7c4ca58903d274531feae9461b175cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuj_1_1list_1_1lnode.html">lnode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ac7c4ca58903d274531feae9461b175cd">head</a></td></tr>
<tr class="separator:ac7c4ca58903d274531feae9461b175cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11ca8e05ea4a38d5752029e80bc2e5c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ad11ca8e05ea4a38d5752029e80bc2e5c">lSize</a> = 0</td></tr>
<tr class="separator:ad11ca8e05ea4a38d5752029e80bc2e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b9c3bcf222cb2f16c5053f70332924"><td class="memItemLeft" align="right" valign="top">node_allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a97b9c3bcf222cb2f16c5053f70332924">alloc</a></td></tr>
<tr class="separator:a97b9c3bcf222cb2f16c5053f70332924"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4fe4df78bbbf3be20e5c95d6d9f0e882"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:a4fe4df78bbbf3be20e5c95d6d9f0e882"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a4fe4df78bbbf3be20e5c95d6d9f0e882">operator==</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4fe4df78bbbf3be20e5c95d6d9f0e882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal.  <a href="#a4fe4df78bbbf3be20e5c95d6d9f0e882">More...</a><br /></td></tr>
<tr class="separator:a4fe4df78bbbf3be20e5c95d6d9f0e882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40cb5b42f257a321a5df8e4f4797249"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:ad40cb5b42f257a321a5df8e4f4797249"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#ad40cb5b42f257a321a5df8e4f4797249">operator!=</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad40cb5b42f257a321a5df8e4f4797249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of lhs and rhs are equal.  <a href="#ad40cb5b42f257a321a5df8e4f4797249">More...</a><br /></td></tr>
<tr class="separator:ad40cb5b42f257a321a5df8e4f4797249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9a9a12737f32c1502b3e89d8cc9cc"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:af8e9a9a12737f32c1502b3e89d8cc9cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#af8e9a9a12737f32c1502b3e89d8cc9cc">operator&lt;</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af8e9a9a12737f32c1502b3e89d8cc9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical less than comparison.  <a href="#af8e9a9a12737f32c1502b3e89d8cc9cc">More...</a><br /></td></tr>
<tr class="separator:af8e9a9a12737f32c1502b3e89d8cc9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389a75ee01482fcf077d55cbd73c6633"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:a389a75ee01482fcf077d55cbd73c6633"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a389a75ee01482fcf077d55cbd73c6633">operator&lt;=</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a389a75ee01482fcf077d55cbd73c6633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical less than or equal comparison.  <a href="#a389a75ee01482fcf077d55cbd73c6633">More...</a><br /></td></tr>
<tr class="separator:a389a75ee01482fcf077d55cbd73c6633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bae333faf0796ef77481f29fc2459da"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:a9bae333faf0796ef77481f29fc2459da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a9bae333faf0796ef77481f29fc2459da">operator&gt;</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9bae333faf0796ef77481f29fc2459da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical greater than comparison.  <a href="#a9bae333faf0796ef77481f29fc2459da">More...</a><br /></td></tr>
<tr class="separator:a9bae333faf0796ef77481f29fc2459da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6f7f6baa85cbd50f9e579c77ce9f06"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:a3e6f7f6baa85cbd50f9e579c77ce9f06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a3e6f7f6baa85cbd50f9e579c77ce9f06">operator&gt;=</a> (const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3e6f7f6baa85cbd50f9e579c77ce9f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical greater than or equal comparison.  <a href="#a3e6f7f6baa85cbd50f9e579c77ce9f06">More...</a><br /></td></tr>
<tr class="separator:a3e6f7f6baa85cbd50f9e579c77ce9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad16c821c70286e681ffa4c14f33ccb"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:a6ad16c821c70286e681ffa4c14f33ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuj_1_1list.html#a6ad16c821c70286e681ffa4c14f33ccb">swap</a> (<a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;lhs, <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6ad16c821c70286e681ffa4c14f33ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialises swap algorithm.  <a href="#a6ad16c821c70286e681ffa4c14f33ccb">More...</a><br /></td></tr>
<tr class="separator:a6ad16c821c70286e681ffa4c14f33ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;<br />
class uj::list&lt; T, Allocator &gt;</h3>

<p>Forward List providing C++98 std::list interface. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Does not support reverse iterators </dd>
<dd>
Unless mentioned <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterator remains valid iterator, but may become <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> after certain operations. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7f73131d3d2629368cd2163a4ad1e016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::<a class="el" href="classuj_1_1list.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty list with given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator to be used by the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5e99332f5254f5e14dcaf10ceca8d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::<a class="el" href="classuj_1_1list.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a list with count copies of value and given allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of new elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of new elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator to be used by the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in count </dd></dl>

</div>
</div>
<a class="anchor" id="a8a0eb3ced8b9f1cecf8684eb0abb2a71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::<a class="el" href="classuj_1_1list.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a list that is copy of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in other.size() </dd></dl>

</div>
</div>
<a class="anchor" id="a26a154fc81ccbcc4c2959888eb07bd33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::<a class="el" href="classuj_1_1list.html">list</a> </td>
          <td>(</td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs list of elements from range [first,last) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first element in range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator beyond the last element in range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Allocator to be used by the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::distance(first,last) </dd></dl>

</div>
</div>
<a class="anchor" id="a33555e4d12b70b7f4a549ee272c12e64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::~<a class="el" href="classuj_1_1list.html">list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace3f16b79ad9f8ac02ed57561dd72f29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces contents with count copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of new elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of new elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>+count </dd>
<dd>
All references and iterators (except <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a>) are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="a3dabeac77f79554df076e5375638c972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces contents with elements from range [first,last) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first element in range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator beyond the last element in range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>+std::distance(first,last) </dd>
<dd>
All references and iterators (except <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a>) are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="ad351b071e23267df2b55a5695b10e89c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in list. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element in list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a1860de7b9c9cc199f7fd59ca69d9c8cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the last element in list. </p>
<dl class="section return"><dt>Returns</dt><dd>Const Reference to the last element in list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="af0a1fe7d357ed44259df7a328b89c4ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a708f029f9af501bba9fc52311034cc24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const Iterator to the first element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a2e3214ea407fe6a9db3fcbf6d76a0f5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the first elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf98eb7e3f25baefc1da8f1eb2e168d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns const iterator beyond the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the first elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a463c8cc0b559f340f0757bb792763f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
All references and iterators (except <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a>) are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="aec29823b4a22c6dafb337ff87d733dd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the list has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the list is empty, otherwise false </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="aa72e3fd272936a3fd2078d16ed970507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator beyond the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a8cac95416397853029513a5cbf0a5b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator beyond the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the first elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a3a06b19c1a88a347a0d66c8e776cde51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes element pointed to by pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator to element to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the next element in the list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
Iterators equal to pos now point to the next element in the list </dd>
<dd>
Iterators equal to std::next(pos) are invalidated </dd>
<dd>
References to removed element are invalidated </dd>
<dd>
Behavior is only defined if pos is not <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa031574b1beddeec3a466964abb6b0c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes elements in range [first,last) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first element to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator beyond the last element to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the next element in the list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::distance(first,last) </dd>
<dd>
Iterators equal to first now point to the next element in the list </dd>
<dd>
Iterators equal to last are invalidated </dd>
<dd>
All references and iterators (except first) to removed elements are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="a1aec3cd86e562e8984b53cb9bba7684c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::freeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuj_1_1list_1_1typenode.html">typenode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys and deallocate given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Pointer to node to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity Constant </dd></dl>

</div>
</div>
<a class="anchor" id="ae27be5e3365bf41da286c6459fc816cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in list. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element in list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="ae03b4c47003b188ccbb29cc439cf8940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the first element in list. </p>
<dl class="section return"><dt>Returns</dt><dd>Const Reference to the first element in list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a259def13bbc1445e2356a366c4f9a648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an instance of Allocator. </p>
<dl class="section return"><dt>Returns</dt><dd>Instance of Allocator </dd></dl>

</div>
</div>
<a class="anchor" id="aeac48a411d84cacb4777a87fd093f437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuj_1_1list_1_1typenode.html">typenode</a>* <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::getNode </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and constructs typenode and element. </p>
<p>Allocator used by the list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Parameters passed to constructed object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to constructed node, nullptr if object constructor throws </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff1eafb5e34e08f20d7576dc2c1a5f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element into the list. </p>
<p>New element is inserted before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to element before which new element will be inserted. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to inserted element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant. </dd>
<dd>
No references are invalidated. </dd>
<dd>
Iterators equal to pos now point to the inserted element </dd></dl>

</div>
</div>
<a class="anchor" id="a7a80b374dbc39399f9b4e3a7d3bf0c9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count new elements into the list. </p>
<p>New element is inserted before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>Iterator to element before which new element will be inserted. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of new values to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of elements to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to inserted element </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in count </dd>
<dd>
No references are invalidated. </dd>
<dd>
Iterators equal to pos now point to the first inserted element </dd></dl>

</div>
</div>
<a class="anchor" id="add8bae4452bdf6bfb3558dec5e77d4d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1iter.html">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first,last) into the list. </p>
<p>New elements is inserted before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to element before which new elements will be inserted. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the first element in range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator beyond the last element in range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::distance(first,last) </dd>
<dd>
No references are invalidated. </dd>
<dd>
Iterators equal to pos now point to the first element inserted </dd></dl>

</div>
</div>
<a class="anchor" id="ac067128544c85d59c4ff6fdf09a13ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the list can contain. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
Typically returns a theoretical number of elements, actual number may be different </dd></dl>

</div>
</div>
<a class="anchor" id="ae88cd7732f47f46ba7c7302d6c1c573f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges sorted elements of two lists. </p>
<p>Elements are compared using operator&lt;</p>
<p>other becomes empty after this operation</p>
<p>no elements are copied </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List to be merged with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>+other.<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
No references are invalidated </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators remain valid, but after the merge they point to the first element in *this, or <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> in other </dd></dl>

</div>
</div>
<a class="anchor" id="aa3cb20c69d69bafab65cf73b0c21a168"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges sorted elements of two lists. </p>
<p>Elements are compared using given comparator comp</p>
<p>comp should have following signature bool(const T&amp;,const T&amp;), const&amp; is not required, but comp must not modify compared elements</p>
<p>other becomes empty after this operation, no elements are copied </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List to be merged with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>Comparator used to compare elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>+other.<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
No references are invalidated </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators remain valid, but after the merge they point to the first element in *this, or <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> in other </dd></dl>

</div>
</div>
<a class="anchor" id="a2370564d27b189b6440e327d6c7d4119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuj_1_1list.html">list</a>&amp; <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces contents of *this with contents of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>+other.<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
All references and iterators to *this (except <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a>) are invalidated </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to *this </dd></dl>

</div>
</div>
<a class="anchor" id="ae8d2c229c12fa753deb71217266dc8b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element from the list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant. </dd>
<dd>
Is a No-op if the list is empty </dd>
<dd>
References and iterators to removed element are invalidated </dd>
<dd>
Iterators equal to <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="afb0456766499b55969eb5cbcfb27884f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element from the list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant. </dd>
<dd>
Is a No-op if the list is empty </dd>
<dd>
References to removed elements are invalidated. </dd>
<dd>
Iterators to removed element and <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> now point to next element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed0b58ea8be3d6cad70a1aa05503f8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the end of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>of element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
Iterators equal to <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> now point to the new element </dd></dl>

</div>
</div>
<a class="anchor" id="a4877f713b86765ffcf8e346e5780d3cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new element at the beginning of the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>of element to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a48c10b0a677be5a0330751da0520d529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes elements equal to value from the list. </p>
<p>Uses operator== to compare the elements </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to which the elements are compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
References to removed elements are invalidated </dd>
<dd>
Iterators to removed elements now point to their respective next element </dd>
<dd>
Iterators to elements following removed elements are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="a4a028fabf75fd826088a7c5380e0ab94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes elements according to the predicate p. </p>
<p>removes an element if p(elem) returns true</p>
<p>p should have following signatue: bool(const T&amp;), const&amp; is not required, but p must not modify tested elements </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>predicate used to check if an element should be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
References to removed elements are invalidated </dd>
<dd>
Iterators to removed elements now point to their respective next element </dd>
<dd>
Iterators to elements following removed elements are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="ae091e85fca96d1593bff39b1f8dcd95f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes size of the list to count. </p>
<p>Removes elements exceeding count if count &lt; this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a></p>
<p>Adds new elements equal to value if count &gt; this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>New size of the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of new elements that may be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> if count &lt; this-&gt;size, otherwise linear in count-this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
If any element is removed all references and iterators to it are invalidated </dd>
<dd>
Iterators to first element removed, are now equal to <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> iterators </dd></dl>

</div>
</div>
<a class="anchor" id="a9e47b0a6d938409f9522a83f4d165058"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of elements in the list. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
No references are invalidated </dd>
<dd>
Iterators remain valid but they now point to different elements </dd>
<dd>
<a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> iterators are now equal to std::next(begin()) </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators remain valid and point to the first element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="a33fe0df001bfc4f80f2a101980d18d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in list. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in list </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa3b9703aca075112c7a5adcc96e109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts contents of the list. </p>
<p>Uses operator&lt; to compare the elements</p>
<p>Uses bubble sort algorithm </p><dl class="section remark"><dt>Remarks</dt><dd>Complexity quadratic in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> (i.e n^2 where n is this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>) </dd>
<dd>
No references are invalidated </dd>
<dd>
Iterators remain valid but now point to different elements </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators now point to first element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="ab41c18abc23c56a499420646852e4b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts contents of the list. </p>
<p>Elements are compared using given comparator comp.</p>
<p>comp should have following signature bool(const T&amp;,const T&amp;), const is not required, but comp must not modify compared elements.</p>
<p>Uses bubble sort algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>Comparison function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity quadratic in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> (i.e n^2 where n is this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a>) </dd>
<dd>
No references are invalidated </dd>
<dd>
Iterators remain valid but now point to different elements </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators now point to first element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="a15767aa53fb9fb98286e1ec1143911a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves all elements from other to *this. </p>
<p>Moves all elements from to before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to element before which the elements will be moved. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List from which the elements are moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in other.size() </dd>
<dd>
No references are invalidated </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators to other remain become valid <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> iterators of other </dd>
<dd>
pos now points to the first element moved </dd>
<dd>
Iterators to other (except <a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a>) are now valid iterators to *this, and <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> iterators of other now point to element previously pointed to by pos </dd></dl>

</div>
</div>
<a class="anchor" id="a936c2e0353fb70178f6e85e48e770907"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves an element from other to *this. </p>
<p>Moves an element pointed to by it to before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to element before which the element will be moved. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List from which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>iterator to element to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
No references are invalidated </dd>
<dd>
pos now points to moved element </dd>
<dd>
it now points to the next element in other </dd></dl>

</div>
</div>
<a class="anchor" id="a3927702816580e6670c7454e1ca1951f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list_1_1citer.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the elements from other to *this. </p>
<p>Moves the elements in range [first,last) to before the element pointed to by the pos </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>iterator to element before which the elements will be moved. May be <a class="el" href="classuj_1_1list.html#aa72e3fd272936a3fd2078d16ed970507" title="Returns an iterator beyond the last element. ">end()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List from which the elements are moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>iterator to the first element to be moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>iterator beyond the last element to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant if *this==other, otherwise linear in std::distance(first,last) </dd>
<dd>
Results are undefined if pos is in range [first,last) </dd>
<dd>
No references are invalidated </dd>
<dd>
pos now points to the first element inserted </dd>
<dd>
first now points to the element previously pointed to by last </dd>
<dd>
last now points to the element previously pointed to by pos </dd></dl>

</div>
</div>
<a class="anchor" id="a3ee7202eab1d35b5b6774e749d9497a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of *this and other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>List to be swapped with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
No references are invalidated </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators remain valid, but after the swap they point to the first element in their respective container </dd></dl>

</div>
</div>
<a class="anchor" id="addcb44aaa1d92c79e078bef09b676e16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes consecutive duplicate elements from the list. </p>
<p>Uses operator== to compare elements </p><dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
References to removed elements are invalidated </dd>
<dd>
Iterators to removed elements now point to their respective next element </dd>
<dd>
Iterators to elements following removed elements are invalidated </dd></dl>

</div>
</div>
<a class="anchor" id="ae58091984701c4bb5083b958b6d554a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes consecutive duplicate elements from the list. </p>
<p>Elements are compared using given predicate p</p>
<p>p should have following signature bool(const T&amp;,const T&amp;), const is not required, but p must not modify compared elements </p><dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in this-&gt;<a class="el" href="classuj_1_1list.html#a33fe0df001bfc4f80f2a101980d18d1b" title="Returns the number of elements in list. ">size()</a> </dd>
<dd>
References to removed elements are invalidated </dd>
<dd>
Iterators to removed elements now point to their respective next element </dd>
<dd>
Iterators to elements following removed elements are invalidated </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad40cb5b42f257a321a5df8e4f4797249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal. </p>
<p>Checks whether lhs.size() == rhs.size() and each element in lhs compares equal with the element in rhs at the same position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be EqualityComparable </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if the contents of the containers are equal, otherwise true </dd></dl>

</div>
</div>
<a class="anchor" id="af8e9a9a12737f32c1502b3e89d8cc9cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical less than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be LessThanComparable </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is lexicographically less than rhs, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a389a75ee01482fcf077d55cbd73c6633"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical less than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is lexicographically less than or equal rhs, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a4fe4df78bbbf3be20e5c95d6d9f0e882"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of lhs and rhs are equal. </p>
<p>Checks whether lhs.size() == rhs.size() and each element in lhs compares equal with the element in rhs at the same position</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be EqualityComparable </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of the containers are equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a9bae333faf0796ef77481f29fc2459da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical greater than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be LessThanComparable </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is lexicographically greater than rhs, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a3e6f7f6baa85cbd50f9e579c77ce9f06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical greater than or equal comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>list to be compared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>list to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity linear in std::min(lhs.size(),rhs.size()) </dd>
<dd>
Requires T to be LessThanComparable </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhs is lexicographically greater than or equal rhs, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a6ad16c821c70286e681ffa4c14f33ccb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuj_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialises swap algorithm. </p>
<p>Equivalent of calling lhs.swap(rhs)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>List to be swapped with rhs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>List to be swapped with lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Complexity constant </dd>
<dd>
No references are invalidated </dd>
<dd>
<a class="el" href="classuj_1_1list.html#af0a1fe7d357ed44259df7a328b89c4ce" title="Returns an iterator to the first element. ">begin()</a> iterators remain valid, but after the swap they point to the first element in their respective container </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a97b9c3bcf222cb2f16c5053f70332924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_allocator_type <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of elements contained in the list </p>

</div>
</div>
<a class="anchor" id="ac7c4ca58903d274531feae9461b175cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuj_1_1list_1_1lnode.html">lnode</a> <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::head</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sentinel node </p>

</div>
</div>
<a class="anchor" id="ad11ca8e05ea4a38d5752029e80bc2e5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classuj_1_1list.html">uj::list</a>&lt; T, Allocator &gt;::lSize = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to last node in sequence. Can point to head when list is empty </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="uj__list_8hpp_source.html">uj_list.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceuj.html">uj</a></li><li class="navelem"><a class="el" href="classuj_1_1list.html">list</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
